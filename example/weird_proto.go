// Code generated by protogen. DO NOT EDIT.

package example

import (
	"fmt"

	"github.com/VictoriaMetrics/easyproto"
)

// MarshalProtobuf marshals A into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *A) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals A fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *A) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	x.B.MarshalProtobufTo(mm.AppendMessage(1))
}

// UnmarshalProtobuf unmarshals A from protobuf message at src.
func (x *A) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.B = B{}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in A: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read A.B data")
			}
			if err := x.B.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal A.B: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals B into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *B) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals B fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *B) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.b)
}

// UnmarshalProtobuf unmarshals B from protobuf message at src.
func (x *B) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.b = ""

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in B: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read B.b")
			}
			x.b = v
		}
	}
	return nil
}

// MarshalProtobuf marshals d into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *d) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals d fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *d) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.dd)
}

// UnmarshalProtobuf unmarshals d from protobuf message at src.
func (x *d) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.dd = ""

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in d: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read d.dd")
			}
			x.dd = v
		}
	}
	return nil
}

// MarshalProtobuf marshals d1 into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *d1) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals d1 fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *d1) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	x.ddd.MarshalProtobufTo(mm.AppendMessage(1))
}

// UnmarshalProtobuf unmarshals d1 from protobuf message at src.
func (x *d1) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.ddd = d{}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in d1: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read d1.ddd data")
			}
			if err := x.ddd.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal d1.ddd: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals d2 into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *d2) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals d2 fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *d2) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	x.d.MarshalProtobufTo(mm.AppendMessage(1))
}

// UnmarshalProtobuf unmarshals d2 from protobuf message at src.
func (x *d2) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.d = d{}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in d2: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read d2.d data")
			}
			if err := x.d.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal d2.d: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals all2 into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *all2) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals all2 fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *all2) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	x.all.MarshalProtobufTo(mm.AppendMessage(1))
}

// UnmarshalProtobuf unmarshals all2 from protobuf message at src.
func (x *all2) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.all = all1{}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in all2: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read all2.all data")
			}
			if err := x.all.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal all2.all: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals all3 into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *all3) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals all3 fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *all3) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	x.all1.MarshalProtobufTo(mm.AppendMessage(1))
	for k, v := range x.aa {
		mm2 := mm.AppendMessage(2)
		mm2.AppendString(1, k)
		v.MarshalProtobufTo(mm2.AppendMessage(2))
	}
	for i := range x.bb {
		x.bb[i].MarshalProtobufTo(mm.AppendMessage(3))
	}
}

// UnmarshalProtobuf unmarshals all3 from protobuf message at src.
func (x *all3) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.all1 = all1{}
	for k := range x.aa {
		delete(x.aa, k)
	}
	x.bb = x.bb[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in all3: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read all3.all1 data")
			}
			if err := x.all1.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal all3.all1: %w", err)
			}
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read all3.aa data")
			}
			var mk string
			var mv all2
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read all3.aa entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.String()
					if !ok {
						return fmt.Errorf("cannot read all3.aa key")
					}
					mk = kv
				case 2:
					vdata, ok := fc2.MessageData()
					if !ok {
						return fmt.Errorf("cannot read all3.aa value data")
					}
					if err := mv.UnmarshalProtobuf(vdata); err != nil {
						return fmt.Errorf("cannot unmarshal all3.aa value: %w", err)
					}
				}
			}
			if x.aa == nil {
				x.aa = make(map[string]all2)
			}
			x.aa[mk] = mv
		case 3:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read all3.bb data")
			}
			x.bb = append(x.bb, all1{})
			item := &x.bb[len(x.bb)-1]
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal all3.bb: %w", err)
			}
		}
	}
	return nil
}
