// Code generated by protogen. DO NOT EDIT.

package example

import (
	"fmt"

	"github.com/VictoriaMetrics/easyproto"
)

var _mp easyproto.MarshalerPool

// ProtobufMarshaler is the interface for types that can marshal to protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufMarshaler interface {
	MarshalProtobufTo(mm *easyproto.MessageMarshaler)
}

// ProtobufUnmarshaler is the interface for types that can unmarshal from protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufUnmarshaler interface {
	UnmarshalProtobuf(src []byte) error
}

// MarshalProtobuf marshals Timeseries into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *Timeseries) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals Timeseries fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *Timeseries) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.Name)
	for i := range x.Samples {
		x.Samples[i].MarshalProtobufTo(mm.AppendMessage(2))
	}
}

// UnmarshalProtobuf unmarshals Timeseries from protobuf message at src.
func (x *Timeseries) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Name = *new(string)
	x.Samples = x.Samples[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in Timeseries: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read Timeseries.Name")
			}
			x.Name = v
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read Timeseries.Samples data")
			}
			x.Samples = append(x.Samples, Sample{})
			item := &x.Samples[len(x.Samples)-1]
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal Timeseries.Samples: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals Sample into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *Sample) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals Sample fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *Sample) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendDouble(1, x.Value)
	mm.AppendInt64(2, x.Timestamp)
}

// UnmarshalProtobuf unmarshals Sample from protobuf message at src.
func (x *Sample) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Value = *new(float64)
	x.Timestamp = *new(int64)

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in Sample: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.Double()
			if !ok {
				return fmt.Errorf("cannot read Sample.Value")
			}
			x.Value = v
		case 2:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read Sample.Timestamp")
			}
			x.Timestamp = v
		}
	}
	return nil
}

// MarshalProtobuf marshals AllTypes into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *AllTypes) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals AllTypes fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *AllTypes) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.StrField)
	mm.AppendBytes(2, x.BytesField)
	mm.AppendInt32(3, x.Int32Field)
	mm.AppendInt64(4, x.Int64Field)
	mm.AppendUint32(5, x.Uint32Field)
	mm.AppendUint64(6, x.Uint64Field)
	mm.AppendSint32(7, x.Sint32Field)
	mm.AppendSint64(8, x.Sint64Field)
	mm.AppendBool(9, x.BoolField)
	mm.AppendDouble(10, x.DoubleField)
	mm.AppendFloat(11, x.FloatField)
	mm.AppendFixed32(12, x.Fixed32Field)
	mm.AppendFixed64(13, x.Fixed64Field)
	mm.AppendSfixed32(14, x.Sfixed32Field)
	mm.AppendSfixed64(15, x.Sfixed64Field)
}

// UnmarshalProtobuf unmarshals AllTypes from protobuf message at src.
func (x *AllTypes) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.StrField = *new(string)
	x.BytesField = *new([]byte)
	x.Int32Field = *new(int32)
	x.Int64Field = *new(int64)
	x.Uint32Field = *new(uint32)
	x.Uint64Field = *new(uint64)
	x.Sint32Field = *new(int32)
	x.Sint64Field = *new(int64)
	x.BoolField = *new(bool)
	x.DoubleField = *new(float64)
	x.FloatField = *new(float32)
	x.Fixed32Field = *new(uint32)
	x.Fixed64Field = *new(uint64)
	x.Sfixed32Field = *new(int32)
	x.Sfixed64Field = *new(int64)

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in AllTypes: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.StrField")
			}
			x.StrField = v
		case 2:
			v, ok := fc.Bytes()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.BytesField")
			}
			x.BytesField = v
		case 3:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Int32Field")
			}
			x.Int32Field = v
		case 4:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Int64Field")
			}
			x.Int64Field = v
		case 5:
			v, ok := fc.Uint32()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Uint32Field")
			}
			x.Uint32Field = v
		case 6:
			v, ok := fc.Uint64()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Uint64Field")
			}
			x.Uint64Field = v
		case 7:
			v, ok := fc.Sint32()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Sint32Field")
			}
			x.Sint32Field = v
		case 8:
			v, ok := fc.Sint64()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Sint64Field")
			}
			x.Sint64Field = v
		case 9:
			v, ok := fc.Bool()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.BoolField")
			}
			x.BoolField = v
		case 10:
			v, ok := fc.Double()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.DoubleField")
			}
			x.DoubleField = v
		case 11:
			v, ok := fc.Float()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.FloatField")
			}
			x.FloatField = v
		case 12:
			v, ok := fc.Fixed32()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Fixed32Field")
			}
			x.Fixed32Field = v
		case 13:
			v, ok := fc.Fixed64()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Fixed64Field")
			}
			x.Fixed64Field = v
		case 14:
			v, ok := fc.Sfixed32()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Sfixed32Field")
			}
			x.Sfixed32Field = v
		case 15:
			v, ok := fc.Sfixed64()
			if !ok {
				return fmt.Errorf("cannot read AllTypes.Sfixed64Field")
			}
			x.Sfixed64Field = v
		}
	}
	return nil
}

// MarshalProtobuf marshals OptionalFields into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *OptionalFields) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals OptionalFields fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *OptionalFields) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	if x.Name != nil {
		mm.AppendString(1, *x.Name)
	}
	if x.Age != nil {
		mm.AppendInt32(2, *x.Age)
	}
	if x.Score != nil {
		mm.AppendDouble(3, *x.Score)
	}
	if x.IsActive != nil {
		mm.AppendBool(4, *x.IsActive)
	}
}

// UnmarshalProtobuf unmarshals OptionalFields from protobuf message at src.
func (x *OptionalFields) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Name = nil
	x.Age = nil
	x.Score = nil
	x.IsActive = nil

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in OptionalFields: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read OptionalFields.Name")
			}
			x.Name = &v
		case 2:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read OptionalFields.Age")
			}
			x.Age = &v
		case 3:
			v, ok := fc.Double()
			if !ok {
				return fmt.Errorf("cannot read OptionalFields.Score")
			}
			x.Score = &v
		case 4:
			v, ok := fc.Bool()
			if !ok {
				return fmt.Errorf("cannot read OptionalFields.IsActive")
			}
			x.IsActive = &v
		}
	}
	return nil
}

// MarshalProtobuf marshals NestedMessage into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *NestedMessage) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals NestedMessage fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *NestedMessage) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendInt64(1, x.ID)
	x.Outer.MarshalProtobufTo(mm.AppendMessage(2))
	if x.Optional != nil {
		x.Optional.MarshalProtobufTo(mm.AppendMessage(3))
	}
	for i := range x.Items {
		x.Items[i].MarshalProtobufTo(mm.AppendMessage(4))
	}
}

// UnmarshalProtobuf unmarshals NestedMessage from protobuf message at src.
func (x *NestedMessage) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.ID = *new(int64)
	x.Outer = *new(Sample)
	x.Optional = nil
	x.Items = x.Items[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in NestedMessage: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read NestedMessage.ID")
			}
			x.ID = v
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read NestedMessage.Outer data")
			}
			if err := x.Outer.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal NestedMessage.Outer: %w", err)
			}
		case 3:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read NestedMessage.Optional data")
			}
			if x.Optional == nil {
				x.Optional = &Sample{}
			}
			if err := x.Optional.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal NestedMessage.Optional: %w", err)
			}
		case 4:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read NestedMessage.Items data")
			}
			x.Items = append(x.Items, Sample{})
			item := &x.Items[len(x.Items)-1]
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal NestedMessage.Items: %w", err)
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals WithPointers into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *WithPointers) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals WithPointers fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *WithPointers) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendInt64(1, x.ID)
	for _, item := range x.Samples {
		if item != nil {
			item.MarshalProtobufTo(mm.AppendMessage(2))
		}
	}
}

// UnmarshalProtobuf unmarshals WithPointers from protobuf message at src.
func (x *WithPointers) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.ID = *new(int64)
	x.Samples = x.Samples[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in WithPointers: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read WithPointers.ID")
			}
			x.ID = v
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read WithPointers.Samples data")
			}
			item := &Sample{}
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal WithPointers.Samples: %w", err)
			}
			x.Samples = append(x.Samples, item)
		}
	}
	return nil
}

// MarshalProtobuf marshals WithEnums into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *WithEnums) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals WithEnums fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *WithEnums) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendInt64(1, x.ID)
	mm.AppendInt32(2, int32(x.Status))
	if x.OptStatus != nil {
		mm.AppendInt32(3, int32(*x.OptStatus))
	}
	for _, v := range x.Statuses {
		mm.AppendInt32(4, int32(v))
	}
}

// UnmarshalProtobuf unmarshals WithEnums from protobuf message at src.
func (x *WithEnums) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.ID = *new(int64)
	x.Status = 0
	x.OptStatus = nil
	x.Statuses = x.Statuses[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in WithEnums: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read WithEnums.ID")
			}
			x.ID = v
		case 2:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read WithEnums.Status")
			}
			x.Status = Status(v)
		case 3:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read WithEnums.OptStatus")
			}
			tmp := Status(v)
			x.OptStatus = &tmp
		case 4:
			if v, ok := fc.Int32(); ok {
				x.Statuses = append(x.Statuses, Status(v))
			} else {
				return fmt.Errorf("cannot read WithEnums.Statuses")
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals RepeatedScalars into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *RepeatedScalars) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals RepeatedScalars fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *RepeatedScalars) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendInt32s(1, x.Int32s)
	mm.AppendInt64s(2, x.Int64s)
	mm.AppendUint32s(3, x.Uint32s)
	mm.AppendUint64s(4, x.Uint64s)
	mm.AppendSint32s(5, x.Sint32s)
	mm.AppendSint64s(6, x.Sint64s)
	mm.AppendBools(7, x.Bools)
	mm.AppendDoubles(8, x.Doubles)
	mm.AppendFloats(9, x.Floats)
	mm.AppendFixed32s(10, x.Fixed32s)
	mm.AppendFixed64s(11, x.Fixed64s)
	mm.AppendSfixed32s(12, x.Sfixed32s)
	mm.AppendSfixed64s(13, x.Sfixed64s)
}

// UnmarshalProtobuf unmarshals RepeatedScalars from protobuf message at src.
func (x *RepeatedScalars) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Int32s = x.Int32s[:0]
	x.Int64s = x.Int64s[:0]
	x.Uint32s = x.Uint32s[:0]
	x.Uint64s = x.Uint64s[:0]
	x.Sint32s = x.Sint32s[:0]
	x.Sint64s = x.Sint64s[:0]
	x.Bools = x.Bools[:0]
	x.Doubles = x.Doubles[:0]
	x.Floats = x.Floats[:0]
	x.Fixed32s = x.Fixed32s[:0]
	x.Fixed64s = x.Fixed64s[:0]
	x.Sfixed32s = x.Sfixed32s[:0]
	x.Sfixed64s = x.Sfixed64s[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in RepeatedScalars: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			var ok bool
			x.Int32s, ok = fc.UnpackInt32s(x.Int32s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Int32s")
			}
		case 2:
			var ok bool
			x.Int64s, ok = fc.UnpackInt64s(x.Int64s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Int64s")
			}
		case 3:
			var ok bool
			x.Uint32s, ok = fc.UnpackUint32s(x.Uint32s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Uint32s")
			}
		case 4:
			var ok bool
			x.Uint64s, ok = fc.UnpackUint64s(x.Uint64s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Uint64s")
			}
		case 5:
			var ok bool
			x.Sint32s, ok = fc.UnpackSint32s(x.Sint32s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Sint32s")
			}
		case 6:
			var ok bool
			x.Sint64s, ok = fc.UnpackSint64s(x.Sint64s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Sint64s")
			}
		case 7:
			var ok bool
			x.Bools, ok = fc.UnpackBools(x.Bools)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Bools")
			}
		case 8:
			var ok bool
			x.Doubles, ok = fc.UnpackDoubles(x.Doubles)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Doubles")
			}
		case 9:
			var ok bool
			x.Floats, ok = fc.UnpackFloats(x.Floats)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Floats")
			}
		case 10:
			var ok bool
			x.Fixed32s, ok = fc.UnpackFixed32s(x.Fixed32s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Fixed32s")
			}
		case 11:
			var ok bool
			x.Fixed64s, ok = fc.UnpackFixed64s(x.Fixed64s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Fixed64s")
			}
		case 12:
			var ok bool
			x.Sfixed32s, ok = fc.UnpackSfixed32s(x.Sfixed32s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Sfixed32s")
			}
		case 13:
			var ok bool
			x.Sfixed64s, ok = fc.UnpackSfixed64s(x.Sfixed64s)
			if !ok {
				return fmt.Errorf("cannot read RepeatedScalars.Sfixed64s")
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals RepeatedStringsBytes into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *RepeatedStringsBytes) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals RepeatedStringsBytes fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *RepeatedStringsBytes) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	for _, v := range x.Strings {
		mm.AppendString(1, v)
	}
	for _, v := range x.Blobs {
		mm.AppendBytes(2, v)
	}
}

// UnmarshalProtobuf unmarshals RepeatedStringsBytes from protobuf message at src.
func (x *RepeatedStringsBytes) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Strings = x.Strings[:0]
	x.Blobs = x.Blobs[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in RepeatedStringsBytes: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read RepeatedStringsBytes.Strings")
			}
			x.Strings = append(x.Strings, v)
		case 2:
			v, ok := fc.Bytes()
			if !ok {
				return fmt.Errorf("cannot read RepeatedStringsBytes.Blobs")
			}
			x.Blobs = append(x.Blobs, v)
		}
	}
	return nil
}

// MarshalProtobuf marshals WithMaps into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *WithMaps) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals WithMaps fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *WithMaps) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	for k, v := range x.StringToInt {
		mm2 := mm.AppendMessage(1)
		mm2.AppendString(1, k)
		mm2.AppendInt32(2, v)
	}
	for k, v := range x.IntToString {
		mm2 := mm.AppendMessage(2)
		mm2.AppendInt64(1, k)
		mm2.AppendString(2, v)
	}
	for k, v := range x.StringToMsg {
		mm2 := mm.AppendMessage(3)
		mm2.AppendString(1, k)
		if v != nil {
			v.MarshalProtobufTo(mm2.AppendMessage(2))
		}
	}
}

// UnmarshalProtobuf unmarshals WithMaps from protobuf message at src.
func (x *WithMaps) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	for k := range x.StringToInt {
		delete(x.StringToInt, k)
	}
	for k := range x.IntToString {
		delete(x.IntToString, k)
	}
	for k := range x.StringToMsg {
		delete(x.StringToMsg, k)
	}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in WithMaps: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read WithMaps.StringToInt data")
			}
			var mk string
			var mv int32
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read WithMaps.StringToInt entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.String()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.StringToInt key")
					}
					mk = kv
				case 2:
					vv, ok := fc2.Int32()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.StringToInt value")
					}
					mv = vv
				}
			}
			if x.StringToInt == nil {
				x.StringToInt = make(map[string]int32)
			}
			x.StringToInt[mk] = mv
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read WithMaps.IntToString data")
			}
			var mk int64
			var mv string
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read WithMaps.IntToString entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.Int64()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.IntToString key")
					}
					mk = kv
				case 2:
					vv, ok := fc2.String()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.IntToString value")
					}
					mv = vv
				}
			}
			if x.IntToString == nil {
				x.IntToString = make(map[int64]string)
			}
			x.IntToString[mk] = mv
		case 3:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read WithMaps.StringToMsg data")
			}
			var mk string
			var mv *Sample
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read WithMaps.StringToMsg entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.String()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.StringToMsg key")
					}
					mk = kv
				case 2:
					vdata, ok := fc2.MessageData()
					if !ok {
						return fmt.Errorf("cannot read WithMaps.StringToMsg value data")
					}
					mv = &Sample{}
					if err := mv.UnmarshalProtobuf(vdata); err != nil {
						return fmt.Errorf("cannot unmarshal WithMaps.StringToMsg value: %w", err)
					}
				}
			}
			if x.StringToMsg == nil {
				x.StringToMsg = make(map[string]*Sample)
			}
			x.StringToMsg[mk] = mv
		}
	}
	return nil
}

// MarshalProtobuf marshals InferredTypes into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *InferredTypes) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals InferredTypes fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *InferredTypes) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.Name)
	mm.AppendInt32(2, x.Age)
	mm.AppendDouble(3, x.Score)
	mm.AppendBool(4, x.IsActive)
	mm.AppendBytes(5, x.Data)
	mm.AppendInt64(6, x.BigNum)
	mm.AppendFloat(7, x.SmallNum)
	mm.AppendUint32(8, x.Unsigned)
	mm.AppendUint64(9, x.BigUnsign)
	if x.Inner != nil {
		x.Inner.MarshalProtobufTo(mm.AppendMessage(10))
	}
	for i := range x.Items {
		x.Items[i].MarshalProtobufTo(mm.AppendMessage(11))
	}
	for k, v := range x.Lookup {
		mm2 := mm.AppendMessage(12)
		mm2.AppendString(1, k)
		mm2.AppendInt32(2, v)
	}
	mm.AppendInt64s(13, x.Numbers)
}

// UnmarshalProtobuf unmarshals InferredTypes from protobuf message at src.
func (x *InferredTypes) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Name = *new(string)
	x.Age = *new(int32)
	x.Score = *new(float64)
	x.IsActive = *new(bool)
	x.Data = *new([]byte)
	x.BigNum = *new(int64)
	x.SmallNum = *new(float32)
	x.Unsigned = *new(uint32)
	x.BigUnsign = *new(uint64)
	x.Inner = nil
	x.Items = x.Items[:0]
	for k := range x.Lookup {
		delete(x.Lookup, k)
	}
	x.Numbers = x.Numbers[:0]

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in InferredTypes: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Name")
			}
			x.Name = v
		case 2:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Age")
			}
			x.Age = v
		case 3:
			v, ok := fc.Double()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Score")
			}
			x.Score = v
		case 4:
			v, ok := fc.Bool()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.IsActive")
			}
			x.IsActive = v
		case 5:
			v, ok := fc.Bytes()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Data")
			}
			x.Data = v
		case 6:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.BigNum")
			}
			x.BigNum = v
		case 7:
			v, ok := fc.Float()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.SmallNum")
			}
			x.SmallNum = v
		case 8:
			v, ok := fc.Uint32()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Unsigned")
			}
			x.Unsigned = v
		case 9:
			v, ok := fc.Uint64()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.BigUnsign")
			}
			x.BigUnsign = v
		case 10:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Inner data")
			}
			if x.Inner == nil {
				x.Inner = &Sample{}
			}
			if err := x.Inner.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal InferredTypes.Inner: %w", err)
			}
		case 11:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Items data")
			}
			x.Items = append(x.Items, Sample{})
			item := &x.Items[len(x.Items)-1]
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal InferredTypes.Items: %w", err)
			}
		case 12:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Lookup data")
			}
			var mk string
			var mv int32
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read InferredTypes.Lookup entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.String()
					if !ok {
						return fmt.Errorf("cannot read InferredTypes.Lookup key")
					}
					mk = kv
				case 2:
					vv, ok := fc2.Int32()
					if !ok {
						return fmt.Errorf("cannot read InferredTypes.Lookup value")
					}
					mv = vv
				}
			}
			if x.Lookup == nil {
				x.Lookup = make(map[string]int32)
			}
			x.Lookup[mk] = mv
		case 13:
			var ok bool
			x.Numbers, ok = fc.UnpackInt64s(x.Numbers)
			if !ok {
				return fmt.Errorf("cannot read InferredTypes.Numbers")
			}
		}
	}
	return nil
}

// MarshalProtobuf marshals BigStruct into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *BigStruct) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals BigStruct fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *BigStruct) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.Field1)
	mm.AppendInt32(2, x.Field2)
	mm.AppendInt64(3, x.Field3)
	mm.AppendBool(4, x.Field4)
	mm.AppendDouble(5, x.Field5)
	x.Series.MarshalProtobufTo(mm.AppendMessage(50))
	mm.AppendString(51, x.Field51)
	mm.AppendInt32(52, x.Field52)
}

// UnmarshalProtobuf unmarshals BigStruct from protobuf message at src.
func (x *BigStruct) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Field1 = *new(string)
	x.Field2 = *new(int32)
	x.Field3 = *new(int64)
	x.Field4 = *new(bool)
	x.Field5 = *new(float64)
	x.Series = *new(Timeseries)
	x.Field51 = *new(string)
	x.Field52 = *new(int32)

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in BigStruct: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field1")
			}
			x.Field1 = v
		case 2:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field2")
			}
			x.Field2 = v
		case 3:
			v, ok := fc.Int64()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field3")
			}
			x.Field3 = v
		case 4:
			v, ok := fc.Bool()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field4")
			}
			x.Field4 = v
		case 5:
			v, ok := fc.Double()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field5")
			}
			x.Field5 = v
		case 50:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Series data")
			}
			if err := x.Series.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal BigStruct.Series: %w", err)
			}
		case 51:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field51")
			}
			x.Field51 = v
		case 52:
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read BigStruct.Field52")
			}
			x.Field52 = v
		}
	}
	return nil
}

// MarshalProtobuf marshals SmallStruct into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *SmallStruct) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals SmallStruct fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *SmallStruct) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
	mm.AppendString(1, x.Name)
	x.Series.MarshalProtobufTo(mm.AppendMessage(2))
}

// UnmarshalProtobuf unmarshals SmallStruct from protobuf message at src.
func (x *SmallStruct) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
	x.Name = *new(string)
	x.Series = *new(Timeseries)

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in SmallStruct: %w", err)
		}
		switch fc.FieldNum {
		case 1:
			v, ok := fc.String()
			if !ok {
				return fmt.Errorf("cannot read SmallStruct.Name")
			}
			x.Name = v
		case 2:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read SmallStruct.Series data")
			}
			if err := x.Series.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal SmallStruct.Series: %w", err)
			}
		}
	}
	return nil
}
