package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

const codeTemplate = `// Code generated by protogen. DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"

	"github.com/VictoriaMetrics/easyproto"
)
{{if not .NoHeader}}
var _mp easyproto.MarshalerPool

// ProtobufMarshaler is the interface for types that can marshal to protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufMarshaler interface {
	MarshalProtobufTo(mm *easyproto.MessageMarshaler)
}

// ProtobufUnmarshaler is the interface for types that can unmarshal from protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufUnmarshaler interface {
	UnmarshalProtobuf(src []byte) error
}
{{end}}
{{range $typeName := .TypeNames}}
{{$info := index $.TypeInfos $typeName}}
// MarshalProtobuf marshals {{$info.Name}} into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *{{$info.Name}}) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals {{$info.Name}} fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *{{$info.Name}}) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
{{- range $field := $info.Fields}}
{{marshalField $info $field}}
{{- end}}
}

// UnmarshalProtobuf unmarshals {{$info.Name}} from protobuf message at src.
func (x *{{$info.Name}}) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
{{- range $field := $info.Fields}}
{{resetField $info $field}}
{{- end}}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in {{$info.Name}}: %w", err)
		}
		switch fc.FieldNum {
{{- range $field := $info.Fields}}
{{- if $field.IsOneof}}
{{unmarshalOneofCases $info $field}}
{{- else}}
		case {{$field.FieldNum}}:
{{unmarshalField $info $field}}
{{- end}}
{{- end}}
		}
	}
	return nil
}

{{end}}
`

func generateCode(buf *bytes.Buffer, pkgName string, typeNames []string, typeInfos map[string]*TypeInfo, skipHeader bool) error {
	funcMap := template.FuncMap{
		"marshalField":        marshalField,
		"unmarshalField":      unmarshalField,
		"unmarshalOneofCases": unmarshalOneofCases,
		"resetField":          resetField,
	}

	tmpl, err := template.New("code").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		PackageName string
		TypeNames   []string
		TypeInfos   map[string]*TypeInfo
		NoHeader    bool
	}{
		PackageName: pkgName,
		TypeNames:   typeNames,
		TypeInfos:   typeInfos,
		NoHeader:    skipHeader,
	}

	return tmpl.Execute(buf, data)
}

// marshalField generates marshal code for a single field.
func marshalField(info *TypeInfo, field *FieldInfo) string {
	var buf strings.Builder
	fieldAccess := "x." + field.Name

	// Handle oneof fields with type switch
	if field.IsOneof {
		buf.WriteString(fmt.Sprintf("\tswitch v := %s.(type) {\n", fieldAccess))
		for _, variant := range field.OneofVariants {
			buf.WriteString(fmt.Sprintf("\tcase *%s:\n", variant.TypeName))
			buf.WriteString(fmt.Sprintf("\t\tv.MarshalProtobufTo(mm.AppendMessage(%d))\n", variant.FieldNum))
		}
		buf.WriteString("\t}")
		return buf.String()
	}

	if field.IsMap {
		buf.WriteString(fmt.Sprintf("\tfor k, v := range %s {\n", fieldAccess))
		buf.WriteString(fmt.Sprintf("\t\tmm2 := mm.AppendMessage(%d)\n", field.FieldNum))
		buf.WriteString(fmt.Sprintf("\t\tmm2.%s(1, k)\n", appendFunc(field.MapKeyProto, false)))

		if field.MapValueIsMsg {
			if field.MapValueIsPtr {
				buf.WriteString("\t\tif v != nil {\n")
				buf.WriteString("\t\t\tv.MarshalProtobufTo(mm2.AppendMessage(2))\n")
				buf.WriteString("\t\t}\n")
			} else {
				buf.WriteString("\t\tv.MarshalProtobufTo(mm2.AppendMessage(2))\n")
			}
		} else {
			buf.WriteString(fmt.Sprintf("\t\tmm2.%s(2, v)\n", appendFunc(field.MapValueProto, false)))
		}
		buf.WriteString("\t}")
		return buf.String()
	}

	if field.IsMessage {
		if field.IsPointer && !field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\t%s.MarshalProtobufTo(mm.AppendMessage(%d))\n", fieldAccess, field.FieldNum))
			buf.WriteString("\t}")
		} else if field.IsRepeated && field.IsSliceOfPtr {
			buf.WriteString(fmt.Sprintf("\tfor _, item := range %s {\n", fieldAccess))
			buf.WriteString("\t\tif item != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\titem.MarshalProtobufTo(mm.AppendMessage(%d))\n", field.FieldNum))
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}")
		} else if field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\tfor i := range %s {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\t%s[i].MarshalProtobufTo(mm.AppendMessage(%d))\n", fieldAccess, field.FieldNum))
			buf.WriteString("\t}")
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.MarshalProtobufTo(mm.AppendMessage(%d))", fieldAccess, field.FieldNum))
		}
	} else if field.IsEnum {
		if field.IsPointer && !field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\tmm.AppendInt32(%d, int32(*%s))\n", field.FieldNum, fieldAccess))
			buf.WriteString("\t}")
		} else if field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\tfor _, v := range %s {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\tmm.AppendInt32(%d, int32(v))\n", field.FieldNum))
			buf.WriteString("\t}")
		} else {
			buf.WriteString(fmt.Sprintf("\tmm.AppendInt32(%d, int32(%s))", field.FieldNum, fieldAccess))
		}
	} else if field.IsPointer && !field.IsRepeated {
		buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", fieldAccess))
		buf.WriteString(fmt.Sprintf("\t\tmm.%s(%d, *%s)\n", appendFunc(field.ProtoType, false), field.FieldNum, fieldAccess))
		buf.WriteString("\t}")
	} else if field.IsRepeated {
		buf.WriteString(fmt.Sprintf("\tmm.%s(%d, %s)", appendFunc(field.ProtoType, true), field.FieldNum, fieldAccess))
	} else {
		buf.WriteString(fmt.Sprintf("\tmm.%s(%d, %s)", appendFunc(field.ProtoType, false), field.FieldNum, fieldAccess))
	}

	return buf.String()
}

// unmarshalField generates unmarshal code for a single field.
func unmarshalField(info *TypeInfo, field *FieldInfo) string {
	var buf strings.Builder
	fieldAccess := "x." + field.Name

	if field.IsMap {
		buf.WriteString("\t\t\tdata, ok := fc.MessageData()\n")
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s data\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\tvar mk %s\n", field.MapKeyType))
		buf.WriteString(fmt.Sprintf("\t\t\tvar mv %s\n", field.MapValueType))
		buf.WriteString("\t\t\tvar fc2 easyproto.FieldContext\n")
		buf.WriteString("\t\t\tfor len(data) > 0 {\n")
		buf.WriteString("\t\t\t\tdata, err = fc2.NextField(data)\n")
		buf.WriteString("\t\t\t\tif err != nil {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s entry: %%w\", err)\n", info.Name, field.Name))
		buf.WriteString("\t\t\t\t}\n")
		buf.WriteString("\t\t\t\tswitch fc2.FieldNum {\n")
		buf.WriteString("\t\t\t\tcase 1:\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\t\tkv, ok := fc2.%s()\n", readFunc(field.MapKeyProto)))
		buf.WriteString("\t\t\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s key\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t\t\t}\n")
		buf.WriteString("\t\t\t\t\tmk = kv\n")
		buf.WriteString("\t\t\t\tcase 2:\n")
		if field.MapValueIsMsg {
			buf.WriteString("\t\t\t\t\tvdata, ok := fc2.MessageData()\n")
			buf.WriteString("\t\t\t\t\tif !ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s value data\")\n", info.Name, field.Name))
			buf.WriteString("\t\t\t\t\t}\n")
			if field.MapValueIsPtr {
				baseValueType := strings.TrimPrefix(field.MapValueType, "*")
				buf.WriteString(fmt.Sprintf("\t\t\t\t\tmv = &%s{}\n", baseValueType))
			}
			buf.WriteString("\t\t\t\t\tif err := mv.UnmarshalProtobuf(vdata); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s value: %%w\", err)\n", info.Name, field.Name))
			buf.WriteString("\t\t\t\t\t}\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\t\t\t\tvv, ok := fc2.%s()\n", readFunc(field.MapValueProto)))
			buf.WriteString("\t\t\t\t\tif !ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s value\")\n", info.Name, field.Name))
			buf.WriteString("\t\t\t\t\t}\n")
			buf.WriteString("\t\t\t\t\tmv = vv\n")
		}
		buf.WriteString("\t\t\t\t}\n")
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\tif %s == nil {\n", fieldAccess))
		buf.WriteString(fmt.Sprintf("\t\t\t\t%s = make(%s)\n", fieldAccess, field.GoType))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\t%s[mk] = mv", fieldAccess))
		return buf.String()
	}

	if field.IsMessage {
		buf.WriteString("\t\t\tdata, ok := fc.MessageData()\n")
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s data\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t}\n")

		if field.IsPointer && !field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\t\t\tif %s == nil {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\t\t\t%s = &%s{}\n", fieldAccess, field.ElemType))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\tif err := %s.UnmarshalProtobuf(data); err != nil {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s: %%w\", err)\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}")
		} else if field.IsRepeated && field.IsSliceOfPtr {
			buf.WriteString(fmt.Sprintf("\t\t\titem := &%s{}\n", field.ElemType))
			buf.WriteString("\t\t\tif err := item.UnmarshalProtobuf(data); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s: %%w\", err)\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\t%s = append(%s, item)", fieldAccess, fieldAccess))
		} else if field.IsRepeated {
			buf.WriteString(fmt.Sprintf("\t\t\t%s = append(%s, %s{})\n", fieldAccess, fieldAccess, field.ElemType))
			buf.WriteString(fmt.Sprintf("\t\t\titem := &%s[len(%s)-1]\n", fieldAccess, fieldAccess))
			buf.WriteString("\t\t\tif err := item.UnmarshalProtobuf(data); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s: %%w\", err)\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}")
		} else {
			buf.WriteString(fmt.Sprintf("\t\t\tif err := %s.UnmarshalProtobuf(data); err != nil {\n", fieldAccess))
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s: %%w\", err)\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}")
		}
	} else if field.IsEnum {
		if field.IsPointer && !field.IsRepeated {
			buf.WriteString("\t\t\tv, ok := fc.Int32()\n")
			buf.WriteString("\t\t\tif !ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\ttmp := %s(v)\n", field.ElemType))
			buf.WriteString(fmt.Sprintf("\t\t\t%s = &tmp", fieldAccess))
		} else if field.IsRepeated {
			buf.WriteString("\t\t\tif v, ok := fc.Int32(); ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t%s = append(%s, %s(v))\n", fieldAccess, fieldAccess, field.ElemType))
			buf.WriteString("\t\t\t} else {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}")
		} else {
			buf.WriteString("\t\t\tv, ok := fc.Int32()\n")
			buf.WriteString("\t\t\tif !ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\t%s = %s(v)", fieldAccess, field.BaseType))
		}
	} else if field.IsPointer && !field.IsRepeated {
		buf.WriteString(fmt.Sprintf("\t\t\tv, ok := fc.%s()\n", readFunc(field.ProtoType)))
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\t%s = &v", fieldAccess))
	} else if field.IsRepeated {
		buf.WriteString("\t\t\tvar ok bool\n")
		buf.WriteString(fmt.Sprintf("\t\t\t%s, ok = fc.%s(%s)\n", fieldAccess, unpackFunc(field.ProtoType), fieldAccess))
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t}")
	} else {
		buf.WriteString(fmt.Sprintf("\t\t\tv, ok := fc.%s()\n", readFunc(field.ProtoType)))
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s\")\n", info.Name, field.Name))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\t%s = v", fieldAccess))
	}

	return buf.String()
}

// unmarshalOneofCases generates unmarshal case statements for a oneof field.
func unmarshalOneofCases(info *TypeInfo, field *FieldInfo) string {
	var buf strings.Builder
	fieldAccess := "x." + field.Name

	for _, variant := range field.OneofVariants {
		buf.WriteString(fmt.Sprintf("\t\tcase %d:\n", variant.FieldNum))
		buf.WriteString("\t\t\tdata, ok := fc.MessageData()\n")
		buf.WriteString("\t\t\tif !ok {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot read %s.%s (%s) data\")\n", info.Name, field.Name, variant.TypeName))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\tv := &%s{}\n", variant.TypeName))
		buf.WriteString("\t\t\tif err := v.UnmarshalProtobuf(data); err != nil {\n")
		buf.WriteString(fmt.Sprintf("\t\t\t\treturn fmt.Errorf(\"cannot unmarshal %s.%s (%s): %%w\", err)\n", info.Name, field.Name, variant.TypeName))
		buf.WriteString("\t\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t\t%s = v\n", fieldAccess))
	}

	return buf.String()
}

// resetField generates reset code for a single field.
func resetField(info *TypeInfo, field *FieldInfo) string {
	fieldAccess := "x." + field.Name

	if field.IsOneof {
		return fmt.Sprintf("\t%s = nil", fieldAccess)
	}

	if field.IsMap {
		return fmt.Sprintf("\tfor k := range %s {\n\t\tdelete(%s, k)\n\t}", fieldAccess, fieldAccess)
	}

	if field.IsRepeated {
		return fmt.Sprintf("\t%s = %s[:0]", fieldAccess, fieldAccess)
	}

	if field.IsPointer {
		return fmt.Sprintf("\t%s = nil", fieldAccess)
	}

	if field.IsEnum {
		return fmt.Sprintf("\t%s = 0", fieldAccess)
	}

	return fmt.Sprintf("\t%s = %s", fieldAccess, zeroValue(field.GoType))
}
