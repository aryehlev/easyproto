package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

const codeTemplate = `// Code generated by protogen. DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"

	"github.com/VictoriaMetrics/easyproto"
)
{{if not .NoHeader}}
var _mp easyproto.MarshalerPool

// ProtobufMarshaler is the interface for types that can marshal to protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufMarshaler interface {
	MarshalProtobufTo(mm *easyproto.MessageMarshaler)
}

// ProtobufUnmarshaler is the interface for types that can unmarshal from protobuf.
// Implement this interface to use custom types as nested messages.
type ProtobufUnmarshaler interface {
	UnmarshalProtobuf(src []byte) error
}
{{end}}
{{range $typeName := .TypeNames}}
{{$info := index $.TypeInfos $typeName}}
// MarshalProtobuf marshals {{$info.Name}} into protobuf message, appends this message to dst and returns the result.
//
// This function doesn't allocate memory on repeated calls.
func (x *{{$info.Name}}) MarshalProtobuf(dst []byte) []byte {
	m := _mp.Get()
	x.MarshalProtobufTo(m.MessageMarshaler())
	dst = m.Marshal(dst)
	_mp.Put(m)
	return dst
}

// MarshalProtobufTo marshals {{$info.Name}} fields to the given MessageMarshaler.
// Implements ProtobufMarshaler interface.
func (x *{{$info.Name}}) MarshalProtobufTo(mm *easyproto.MessageMarshaler) {
{{- range $field := $info.Fields}}
{{marshalField $info $field}}
{{- end}}
}

// UnmarshalProtobuf unmarshals {{$info.Name}} from protobuf message at src.
func (x *{{$info.Name}}) UnmarshalProtobuf(src []byte) (err error) {
	// Set default values
{{- range $field := $info.Fields}}
{{resetField $info $field}}
{{- end}}

	// Parse message
	var fc easyproto.FieldContext
	for len(src) > 0 {
		src, err = fc.NextField(src)
		if err != nil {
			return fmt.Errorf("cannot read next field in {{$info.Name}}: %w", err)
		}
		switch fc.FieldNum {
{{- range $field := $info.Fields}}
{{- if $field.IsOneof}}
{{unmarshalOneofCases $info $field}}
{{- else}}
		case {{$field.FieldNum}}:
{{unmarshalField $info $field}}
{{- end}}
{{- end}}
		}
	}
	return nil
}

{{end}}
`

func generateCode(buf *bytes.Buffer, pkgName string, typeNames []string, typeInfos map[string]*TypeInfo, skipHeader bool) error {
	funcMap := template.FuncMap{
		"marshalField":        marshalField,
		"unmarshalField":      unmarshalField,
		"unmarshalOneofCases": unmarshalOneofCases,
		"resetField":          resetField,
	}

	tmpl, err := template.New("code").Funcs(funcMap).Parse(codeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		PackageName string
		TypeNames   []string
		TypeInfos   map[string]*TypeInfo
		NoHeader    bool
	}{
		PackageName: pkgName,
		TypeNames:   typeNames,
		TypeInfos:   typeInfos,
		NoHeader:    skipHeader,
	}

	return tmpl.Execute(buf, data)
}

// Template helper functions
var helperFuncs = template.FuncMap{
	"appendFunc":        appendFunc,
	"readFunc":          readFunc,
	"unpackFunc":        unpackFunc,
	"isLengthDelimited": func(t string) bool { return t == "string" || t == "bytes" },
	"trimPrefix":        strings.TrimPrefix,
}

func execTemplate(name, tmplStr string, data any) string {
	tmpl := template.Must(template.New(name).Funcs(helperFuncs).Parse(tmplStr))
	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(fmt.Sprintf("template %s failed: %v", name, err))
	}
	return buf.String()
}

// marshalField generates marshal code for a single field.
func marshalField(info *TypeInfo, field *FieldInfo) string {
	const tmpl = `{{$fa := printf "x.%s" .Field.Name}}
{{- if .Field.IsOneof}}
	switch v := {{$fa}}.(type) {
{{- range $variant := .Field.OneofVariants}}
	case *{{$variant.TypeName}}:
		v.MarshalProtobufTo(mm.AppendMessage({{$variant.FieldNum}}))
{{- end}}
	}
{{- else if .Field.IsMap}}
	for k, v := range {{$fa}} {
		mm2 := mm.AppendMessage({{.Field.FieldNum}})
		mm2.{{appendFunc .Field.MapKeyProto false}}(1, k)
{{- if .Field.MapValueIsMsg}}
{{- if .Field.MapValueIsPtr}}
		if v != nil {
			v.MarshalProtobufTo(mm2.AppendMessage(2))
		}
{{- else}}
		v.MarshalProtobufTo(mm2.AppendMessage(2))
{{- end}}
{{- else}}
		mm2.{{appendFunc .Field.MapValueProto false}}(2, v)
{{- end}}
	}
{{- else if .Field.IsMessage}}
{{- if and .Field.IsPointer (not .Field.IsRepeated)}}
	if {{$fa}} != nil {
		{{$fa}}.MarshalProtobufTo(mm.AppendMessage({{.Field.FieldNum}}))
	}
{{- else if and .Field.IsRepeated .Field.IsSliceOfPtr}}
	for _, item := range {{$fa}} {
		if item != nil {
			item.MarshalProtobufTo(mm.AppendMessage({{.Field.FieldNum}}))
		}
	}
{{- else if .Field.IsRepeated}}
	for i := range {{$fa}} {
		{{$fa}}[i].MarshalProtobufTo(mm.AppendMessage({{.Field.FieldNum}}))
	}
{{- else}}
	{{$fa}}.MarshalProtobufTo(mm.AppendMessage({{.Field.FieldNum}}))
{{- end}}
{{- else if .Field.IsEnum}}
{{- if and .Field.IsPointer (not .Field.IsRepeated)}}
	if {{$fa}} != nil {
		mm.AppendInt32({{.Field.FieldNum}}, int32(*{{$fa}}))
	}
{{- else if .Field.IsRepeated}}
	for _, v := range {{$fa}} {
		mm.AppendInt32({{.Field.FieldNum}}, int32(v))
	}
{{- else}}
	mm.AppendInt32({{.Field.FieldNum}}, int32({{$fa}}))
{{- end}}
{{- else if and .Field.IsRepeated (isLengthDelimited .Field.ProtoType)}}
	for _, v := range {{$fa}} {
		mm.{{appendFunc .Field.ProtoType false}}({{.Field.FieldNum}}, v)
	}
{{- else if and .Field.IsPointer (not .Field.IsRepeated)}}
	if {{$fa}} != nil {
		mm.{{appendFunc .Field.ProtoType false}}({{.Field.FieldNum}}, *{{$fa}})
	}
{{- else if .Field.IsRepeated}}
	mm.{{appendFunc .Field.ProtoType true}}({{.Field.FieldNum}}, {{$fa}})
{{- else}}
	mm.{{appendFunc .Field.ProtoType false}}({{.Field.FieldNum}}, {{$fa}})
{{- end}}`
	return execTemplate("marshal", tmpl, map[string]any{"Info": info, "Field": field})
}

// unmarshalField generates unmarshal code for a single field.
func unmarshalField(info *TypeInfo, field *FieldInfo) string {
	const tmpl = `{{$fa := printf "x.%s" .Field.Name}}
{{- if .Field.IsMap}}
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} data")
			}
			var mk {{.Field.MapKeyType}}
			var mv {{.Field.MapValueType}}
			var fc2 easyproto.FieldContext
			for len(data) > 0 {
				data, err = fc2.NextField(data)
				if err != nil {
					return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} entry: %w", err)
				}
				switch fc2.FieldNum {
				case 1:
					kv, ok := fc2.{{readFunc .Field.MapKeyProto}}()
					if !ok {
						return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} key")
					}
					mk = kv
				case 2:
{{- if .Field.MapValueIsMsg}}
					vdata, ok := fc2.MessageData()
					if !ok {
						return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} value data")
					}
{{- if .Field.MapValueIsPtr}}
					mv = &{{trimPrefix .Field.MapValueType "*"}}{}
{{- end}}
					if err := mv.UnmarshalProtobuf(vdata); err != nil {
						return fmt.Errorf("cannot unmarshal {{.Info.Name}}.{{.Field.Name}} value: %w", err)
					}
{{- else}}
					vv, ok := fc2.{{readFunc .Field.MapValueProto}}()
					if !ok {
						return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} value")
					}
					mv = vv
{{- end}}
				}
			}
			if {{$fa}} == nil {
				{{$fa}} = make({{.Field.GoType}})
			}
			{{$fa}}[mk] = mv
{{- else if .Field.IsMessage}}
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}} data")
			}
{{- if and .Field.IsPointer (not .Field.IsRepeated)}}
			if {{$fa}} == nil {
				{{$fa}} = &{{.Field.ElemType}}{}
			}
			if err := {{$fa}}.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal {{.Info.Name}}.{{.Field.Name}}: %w", err)
			}
{{- else if and .Field.IsRepeated .Field.IsSliceOfPtr}}
			item := &{{.Field.ElemType}}{}
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal {{.Info.Name}}.{{.Field.Name}}: %w", err)
			}
			{{$fa}} = append({{$fa}}, item)
{{- else if .Field.IsRepeated}}
			{{$fa}} = append({{$fa}}, {{.Field.ElemType}}{})
			item := &{{$fa}}[len({{$fa}})-1]
			if err := item.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal {{.Info.Name}}.{{.Field.Name}}: %w", err)
			}
{{- else}}
			if err := {{$fa}}.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal {{.Info.Name}}.{{.Field.Name}}: %w", err)
			}
{{- end}}
{{- else if .Field.IsEnum}}
{{- if and .Field.IsPointer (not .Field.IsRepeated)}}
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
			tmp := {{.Field.ElemType}}(v)
			{{$fa}} = &tmp
{{- else if .Field.IsRepeated}}
			if v, ok := fc.Int32(); ok {
				{{$fa}} = append({{$fa}}, {{.Field.ElemType}}(v))
			} else {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
{{- else}}
			v, ok := fc.Int32()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
			{{$fa}} = {{.Field.BaseType}}(v)
{{- end}}
{{- else if and .Field.IsPointer (not .Field.IsRepeated)}}
			v, ok := fc.{{readFunc .Field.ProtoType}}()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
			{{$fa}} = &v
{{- else if and .Field.IsRepeated (isLengthDelimited .Field.ProtoType)}}
			v, ok := fc.{{readFunc .Field.ProtoType}}()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
			{{$fa}} = append({{$fa}}, v)
{{- else if .Field.IsRepeated}}
			var ok bool
			{{$fa}}, ok = fc.{{unpackFunc .Field.ProtoType}}({{$fa}})
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
{{- else}}
			v, ok := fc.{{readFunc .Field.ProtoType}}()
			if !ok {
				return fmt.Errorf("cannot read {{.Info.Name}}.{{.Field.Name}}")
			}
			{{$fa}} = v
{{- end}}`
	return execTemplate("unmarshal", tmpl, map[string]any{"Info": info, "Field": field})
}

// unmarshalOneofCases generates unmarshal case statements for a oneof field.
func unmarshalOneofCases(info *TypeInfo, field *FieldInfo) string {
	const tmpl = `{{$fa := printf "x.%s" .Field.Name}}
{{- range $variant := .Field.OneofVariants}}
		case {{$variant.FieldNum}}:
			data, ok := fc.MessageData()
			if !ok {
				return fmt.Errorf("cannot read {{$.Info.Name}}.{{$.Field.Name}} ({{$variant.TypeName}}) data")
			}
			v := &{{$variant.TypeName}}{}
			if err := v.UnmarshalProtobuf(data); err != nil {
				return fmt.Errorf("cannot unmarshal {{$.Info.Name}}.{{$.Field.Name}} ({{$variant.TypeName}}): %w", err)
			}
			{{$fa}} = v
{{- end}}`
	return execTemplate("oneofCases", tmpl, map[string]any{"Info": info, "Field": field})
}

// resetField generates reset code for a single field.
func resetField(info *TypeInfo, field *FieldInfo) string {
	const tmpl = `{{$fa := printf "x.%s" .Field.Name}}
{{- if .Field.IsOneof}}
	{{$fa}} = nil
{{- else if .Field.IsMap}}
	for k := range {{$fa}} {
		delete({{$fa}}, k)
	}
{{- else if .Field.IsRepeated}}
	{{$fa}} = {{$fa}}[:0]
{{- else if .Field.IsPointer}}
	{{$fa}} = nil
{{- else if .Field.IsEnum}}
	{{$fa}} = 0
{{- else}}
	{{$fa}} = *new({{.Field.GoType}})
{{- end}}`
	return execTemplate("reset", tmpl, map[string]any{"Info": info, "Field": field})
}
